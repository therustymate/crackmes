/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_140001000();
BOOL sub_140001010();
__int64 __fastcall sub_140001060(__int64 a1, __int64 a2);
const char *__fastcall sub_1400010A0(__int64 a1);
char *__fastcall sub_1400010C0(char *Block, char a2);
__int64 __fastcall sub_140001110(_QWORD *a1);
_QWORD *__fastcall sub_140001130(_QWORD *a1);
void __noreturn sub_140001160();
__int64 __fastcall sub_140001180(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400011C0(__int64 a1, __int64 a2);
void __noreturn sub_140001200();
_QWORD *__fastcall sub_140001220(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_1400012F0(_QWORD); // weak
__int64 __fastcall sub_140001350(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140001470(_QWORD *a1);
void __noreturn sub_1400014A0();
__int64 __fastcall sub_1400014C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140001500(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall sub_1400018C0(__int64 a1);
__int64 __fastcall sub_140001A00(__int64 a1);
__int64 __fastcall sub_140001BC0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140001DA0(_QWORD *Src, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_140001F10(_QWORD); // weak
__int64 __fastcall sub_140001F40(_QWORD); // weak
// void *__fastcall operator new(size_t Size); idb
void __cdecl j_j_free(void *Block);
_QWORD *__fastcall sub_140002044(_QWORD *a1, char a2);
_QWORD *__fastcall sub_140002460(_QWORD *a1);
void __noreturn sub_140002480(); // weak
// int __cdecl atexit(void (__cdecl *)());
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
void sub_1400027A8();
char sub_1400027B8();
void *sub_1400027C0();
void *sub_1400027C8();
void *sub_1400027F8();
void *sub_140002800();
void sub_140002808();
void sub_140002A20();
void __fastcall sub_140002A5C();
__int64 sub_140002A98(); // weak
void *__fastcall sub_140002D78(__int64 a1);
// void std::_Xbad_alloc(void); idb
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
__int64 __fastcall sub_140002FB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140002FC0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140002FCC(__int64 a1, __int64 a2);
__int64 __fastcall sub_140002FD8(__int64 a1, __int64 a2);
void __fastcall sub_140002FF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140003070(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000307C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140003088(__int64 a1, __int64 a2);
void sub_140003108();
// __int64 __fastcall std::istream::_Ipfx(_QWORD, _QWORD); weak
// __int64 std::streambuf::sgetc(void); weak
// __int64 __fastcall std::streambuf::snextc(_QWORD); weak
// __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD); weak
// __int64 __fastcall std::ios_base::getloc(_QWORD, _QWORD); weak
// __int64 __fastcall std::ostream::_Osfx(_QWORD); weak
// __int64 __fastcall std::ctype<char>::_Getcat(_QWORD, _QWORD); weak
// __int64 std::ostream::flush(void); weak
// void __noreturn std::_Xlength_error(const char *); weak
// void std::_Lockit::~_Lockit(std::_Lockit *__hidden this); weak
// _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD); weak
// bool std::ios_base::good(std::ios_base *__hidden this); weak
// __int64 std::locale::_Getgloballocale(void); weak
// bool std::uncaught_exception(void); weak
// __int64 __fastcall _std_exception_destroy(_QWORD); weak
// __int64 __fastcall _std_exception_copy(_QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern _UNKNOWN std::cout; weak
// extern _UNKNOWN std::cin; weak
// extern int std::locale::id::_Id_cnt; weak
// extern _UNKNOWN std::ctype<char>::id; weak
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern void (__cdecl *free)(void *Block);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl __noreturn *invalid_parameter_noinfo_noreturn)();
void *type_info::`vftable' = &sub_140002044; // weak
void *std::exception::`vftable' = &sub_1400010C0; // weak
void *std::bad_alloc::`vftable' = &sub_1400010C0; // weak
void *std::bad_array_new_length::`vftable' = &sub_1400010C0; // weak
void *std::bad_cast::`vftable' = &sub_1400010C0; // weak
void (*qword_140004CF0[2])(void) = { NULL, NULL }; // weak
void (*qword_140004D00)(void) = NULL; // weak
__int64 qword_140006050 = -1LL; // weak
int dword_140006058 = 1; // weak
int dword_14000605C = 2; // weak
__int64 qword_140006060 = 524288LL; // weak
__int64 qword_140006068 = 33554432LL; // weak
union _SLIST_HEADER stru_140006700; // weak
_UNKNOWN unk_140006710; // weak
_UNKNOWN unk_140006718; // weak
int dword_140006720; // weak
int dword_140006724; // weak
int dword_140006728; // weak
void *Block; // idb
__int64 qword_140006740; // weak
_UNKNOWN unk_140006748; // weak
_UNKNOWN unk_140006750; // weak


//----- (0000000140001000) ----------------------------------------------------
int sub_140001000()
{
  return atexit(sub_140003108);
}

//----- (0000000140001010) ----------------------------------------------------
BOOL sub_140001010()
{
  if ( IsDebuggerPresent() )
  {
    MessageBoxA(0, "Debugger Detected!", "Bye", 0);
    ExitProcess(0);
  }
  return CloseHandle((HANDLE)0xDEADC0DELL);
}

//----- (0000000140001060) ----------------------------------------------------
__int64 __fastcall sub_140001060(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  return a1;
}
// 140004188: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140004378: using guessed type void *std::exception::`vftable';

//----- (00000001400010A0) ----------------------------------------------------
const char *__fastcall sub_1400010A0(__int64 a1)
{
  const char *result; // rax

  result = "Unknown exception";
  if ( *(_QWORD *)(a1 + 8) )
    return *(const char **)(a1 + 8);
  return result;
}

//----- (00000001400010C0) ----------------------------------------------------
char *__fastcall sub_1400010C0(char *Block, char a2)
{
  *(_QWORD *)Block = &std::exception::`vftable';
  _std_exception_destroy(Block + 8);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 140004168: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 140004378: using guessed type void *std::exception::`vftable';

//----- (0000000140001110) ----------------------------------------------------
__int64 __fastcall sub_140001110(_QWORD *a1)
{
  *a1 = &std::exception::`vftable';
  return _std_exception_destroy(a1 + 1);
}
// 140004168: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 140004378: using guessed type void *std::exception::`vftable';

//----- (0000000140001130) ----------------------------------------------------
_QWORD *__fastcall sub_140001130(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad array new length";
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 1400043B8: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0000000140001160) ----------------------------------------------------
void __noreturn sub_140001160()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_140001130(pExceptionObject);
  throw (std::bad_array_new_length *)pExceptionObject;
}

//----- (0000000140001180) ----------------------------------------------------
__int64 __fastcall sub_140001180(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 140004188: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140004378: using guessed type void *std::exception::`vftable';
// 1400043B8: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00000001400011C0) ----------------------------------------------------
__int64 __fastcall sub_1400011C0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 140004188: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140004378: using guessed type void *std::exception::`vftable';
// 140004390: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140001200) ----------------------------------------------------
void __noreturn sub_140001200()
{
  std::_Xlength_error("string too long");
}
// 1400040E8: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140001220) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
_QWORD *__fastcall sub_140001220(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 i; // rdx
  _QWORD *v5; // r8
  unsigned __int64 v6; // rdx
  _QWORD *v7; // rcx

  sub_140001350((__int64)a1, (__int64)a2);
  for ( i = 0; i < a1[2]; ++i )
  {
    v5 = a1;
    if ( a1[3] > 0xFu )
      v5 = (_QWORD *)*a1;
    *((_BYTE *)v5 + i) ^= 4 * i + i + 33;
  }
  v6 = a2[3];
  if ( v6 > 0xF )
  {
    v7 = (_QWORD *)*a2;
    if ( v6 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v7 - *(v7 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v7 = (_QWORD *)*(v7 - 1);
    }
    j_j_free(v7);
  }
  a2[2] = 0;
  a2[3] = 15;
  *(_BYTE *)a2 = 0;
  return a1;
}

//----- (0000000140001350) ----------------------------------------------------
__int64 __fastcall sub_140001350(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  _OWORD *v4; // rbp
  unsigned __int64 v5; // rsi
  __int64 v6; // rdi
  __int64 result; // rax
  size_t v8; // rax
  void *v9; // rax
  void *v10; // rcx
  size_t v11; // rcx

  v2 = 0;
  *(_OWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = (_OWORD *)a2;
  if ( *(_QWORD *)(a2 + 24) > 0xFu )
    v4 = *(_OWORD **)a2;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v5 > 0x7FFFFFFFFFFFFFFFLL )
    sub_140001200();
  if ( v5 <= 0xF )
  {
    *(_QWORD *)(a1 + 16) = v5;
    result = a1;
    *(_QWORD *)(a1 + 24) = 15;
    *(_OWORD *)a1 = *v4;
    return result;
  }
  if ( (v5 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v8 = 0x8000000000000027uLL;
LABEL_8:
    v9 = operator new(v8);
    v10 = v9;
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v2 = (_QWORD *)(((unsigned __int64)v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v2 - 1) = v10;
    goto LABEL_18;
  }
  v6 = v5 | 0xF;
  if ( (v5 | 0xF) < 0x16 )
    v6 = 22;
  v11 = v6 + 1;
  if ( v6 == -1 )
    goto LABEL_18;
  if ( v11 >= 0x1000 )
  {
    v8 = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_140001160();
    goto LABEL_8;
  }
  v2 = operator new(v11);
LABEL_18:
  *(_QWORD *)a1 = v2;
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  memcpy(v2, v4, v5 + 1);
  return a1;
}

//----- (0000000140001470) ----------------------------------------------------
_QWORD *__fastcall sub_140001470(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad cast";
  *a1 = &std::bad_cast::`vftable';
  return a1;
}
// 1400044B0: using guessed type void *std::bad_cast::`vftable';

//----- (00000001400014A0) ----------------------------------------------------
void __noreturn sub_1400014A0()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_140001470(pExceptionObject);
  throw (std::bad_cast *)pExceptionObject;
}

//----- (00000001400014C0) ----------------------------------------------------
__int64 __fastcall sub_1400014C0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_cast::`vftable';
  return a1;
}
// 140004188: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140004378: using guessed type void *std::exception::`vftable';
// 1400044B0: using guessed type void *std::bad_cast::`vftable';

//----- (0000000140001540) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void **v3; // r14
  char *v4; // rsi
  unsigned __int64 v5; // r13
  __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  size_t v8; // rax
  void *v9; // rax
  void *v10; // rcx
  _QWORD *v11; // rax
  size_t v12; // rcx
  __int64 v13; // rbx
  void **v14; // rdx
  char *v15; // rdi
  unsigned __int64 v16; // r15
  _QWORD *v17; // rcx
  size_t v18; // r8
  bool v19; // r14
  char *v20; // rax
  unsigned __int64 v21; // rdx
  _QWORD *v22; // rcx
  const CHAR *v23; // r8
  const CHAR *v24; // rdx
  void *v25; // rcx
  char *v26; // rax
  __int128 v28; // [rsp+28h] [rbp-81h] BYREF
  __int64 v29; // [rsp+38h] [rbp-71h]
  __int64 v30; // [rsp+40h] [rbp-69h]
  char v31[32]; // [rsp+50h] [rbp-59h] BYREF
  void *Buf2[2]; // [rsp+70h] [rbp-39h] BYREF
  unsigned __int64 v33; // [rsp+80h] [rbp-29h]
  unsigned __int64 v34; // [rsp+88h] [rbp-21h]
  void *Src[2]; // [rsp+90h] [rbp-19h] BYREF
  unsigned __int64 v36; // [rsp+A0h] [rbp-9h]
  unsigned __int64 v37; // [rsp+A8h] [rbp-1h]
  void *Block[3]; // [rsp+B0h] [rbp+7h] BYREF
  unsigned __int64 v39; // [rsp+C8h] [rbp+1Fh]

  sub_140001010();
  *(_OWORD *)Src = 0;
  v36 = 0;
  v37 = 15;
  LOBYTE(Src[0]) = 0;
  sub_140001A00(std::cout);
  sub_140001BC0(std::cin, Src);
  *(_OWORD *)Buf2 = 0;
  v33 = 0;
  v34 = 0;
  v3 = Src;
  v4 = (char *)Src[0];
  v5 = v37;
  if ( v37 > 0xF )
    v3 = (void **)Src[0];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  v7 = v36;
  if ( v36 > 0x7FFFFFFFFFFFFFFFLL )
    sub_140001200();
  if ( v36 <= 0xF )
  {
    v33 = v36;
    v34 = 15;
    *(_OWORD *)Buf2 = *(_OWORD *)v3;
    goto LABEL_20;
  }
  if ( (v36 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v8 = 0x8000000000000027uLL;
LABEL_8:
    v9 = operator new(v8);
    v10 = v9;
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v11 = (_QWORD *)(((unsigned __int64)v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v10;
    goto LABEL_19;
  }
  v6 = v36 | 0xF;
  if ( (v36 | 0xF) < 0x16 )
    v6 = 22;
  v12 = v6 + 1;
  if ( v6 == -1 )
  {
    v11 = 0;
  }
  else
  {
    if ( v12 >= 0x1000 )
    {
      v8 = v6 + 40;
      if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
        sub_140001160();
      goto LABEL_8;
    }
    v11 = operator new(v12);
  }
LABEL_19:
  Buf2[0] = v11;
  v33 = v7;
  v34 = v6;
  memcpy(v11, v3, v7 + 1);
LABEL_20:
  sub_140001220(Block, Buf2);
  v13 = sub_140001350((__int64)v31, (__int64)Block);
  v28 = 0;
  v29 = 4;
  v30 = 15;
  strcpy((char *)&v28, "KIWZ");
  sub_140001220(Buf2, &v28);
  v14 = Buf2;
  v15 = (char *)Buf2[0];
  v16 = v34;
  if ( v34 > 0xF )
    v14 = (void **)Buf2[0];
  v17 = (_QWORD *)v13;
  if ( *(_QWORD *)(v13 + 24) > 0xFu )
    v17 = *(_QWORD **)v13;
  v18 = *(_QWORD *)(v13 + 16);
  if ( v18 == v33 )
  {
    if ( v18 )
      v19 = memcmp(v17, v14, v18) == 0;
    else
      v19 = 1;
  }
  else
  {
    v19 = 0;
  }
  if ( v16 > 0xF )
  {
    v20 = v15;
    if ( v16 + 1 >= 0x1000 )
    {
      v15 = (char *)*((_QWORD *)v15 - 1);
      if ( (unsigned __int64)(v20 - v15 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    j_j_free(v15);
  }
  v33 = 0;
  v34 = 15;
  LOBYTE(Buf2[0]) = 0;
  v21 = *(_QWORD *)(v13 + 24);
  if ( v21 > 0xF )
  {
    v22 = *(_QWORD **)v13;
    if ( v21 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v22 - *(v22 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v22 = (_QWORD *)*(v22 - 1);
    }
    j_j_free(v22);
  }
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 15;
  *(_BYTE *)v13 = 0;
  if ( v19 )
  {
    v23 = "Success";
    v24 = "License Accepted!";
  }
  else
  {
    v23 = "Error";
    v24 = "Invalid License";
  }
  MessageBoxA(0, v24, v23, 0);
  if ( v39 > 0xF )
  {
    v25 = Block[0];
    if ( v39 + 1 >= 0x1000 )
    {
      v25 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v25 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    j_j_free(v25);
  }
  Block[2] = 0;
  v39 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v5 > 0xF )
  {
    v26 = v4;
    if ( v5 + 1 >= 0x1000 )
    {
      v4 = (char *)*((_QWORD *)v4 - 1);
      if ( (unsigned __int64)(v26 - v4 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    j_j_free(v4);
  }
  return 0;
}

//----- (00000001400018C0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_1400018C0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v8; // [rsp+20h] [rbp-28h] BYREF
  _BYTE v9[8]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v10; // [rsp+30h] [rbp-18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
  v8 = qword_140006740;
  if ( !std::ctype<char>::id )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    std::ctype<char>::id = ++std::locale::id::_Id_cnt;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  }
  v2 = *(_QWORD *)(a1 + 8);
  v3 = 8LL * std::ctype<char>::id;
  if ( std::ctype<char>::id >= *(_QWORD *)(v2 + 24) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_QWORD *)(v3 + *(_QWORD *)(v2 + 16));
    if ( v4 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(v2 + 36) )
    goto LABEL_10;
  v5 = std::locale::_Getgloballocale();
  if ( std::ctype<char>::id < *(_QWORD *)(v5 + 24) )
  {
    v4 = *(_QWORD *)(v3 + *(_QWORD *)(v5 + 16));
LABEL_10:
    if ( v4 )
      goto LABEL_14;
  }
  v4 = v8;
  if ( !v8 )
  {
    if ( std::ctype<char>::_Getcat(&v8, a1) == -1 )
      sub_1400014A0();
    v6 = v8;
    v10 = v8;
    sub_140002D78(v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
    v4 = v8;
    qword_140006740 = v8;
  }
LABEL_14:
  std::_Lockit::~_Lockit((std::_Lockit *)v9);
  return v4;
}
// 140001927: write access to const memory at 140004128 has been detected
// 14000192C: write access to const memory at 140004130 has been detected
// 1400040D0: using guessed type __int64 __fastcall std::ctype<char>::_Getcat(_QWORD, _QWORD);
// 1400040F0: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 1400040F8: using guessed type _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 140004110: using guessed type __int64 std::locale::_Getgloballocale(void);
// 140004128: using guessed type int std::locale::id::_Id_cnt;
// 140006740: using guessed type __int64 qword_140006740;

//----- (0000000140001A00) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_140001A00(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // ebx
  __int64 v3; // rdx
  __int64 v4; // rdi
  __int64 v5; // rdi
  __int64 v6; // r14
  __int64 v7; // rcx
  bool v8; // al
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rcx
  int v15; // [rsp+58h] [rbp+10h]

  v1 = a1;
  v2 = 0;
  v15 = 0;
  v3 = *(int *)(*(_QWORD *)a1 + 4LL);
  v4 = *(_QWORD *)(v3 + a1 + 40);
  if ( v4 < 20 )
    v5 = 0;
  else
    v5 = v4 - 19;
  v6 = a1;
  v7 = *(_QWORD *)(v3 + a1 + 72);
  if ( v7 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
  v8 = std::ios_base::good((std::ios_base *)(v1 + *(int *)(*(_QWORD *)v1 + 4LL)));
  if ( v8 )
  {
    v9 = *(_QWORD *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 80);
    if ( !v9 || v9 == v1 )
    {
      v8 = 1;
    }
    else
    {
      std::ostream::flush();
      v8 = std::ios_base::good((std::ios_base *)(v1 + *(int *)(*(_QWORD *)v1 + 4LL)));
    }
  }
  if ( v8 )
  {
    try
    {
      if ( (*(_DWORD *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 24) & 0x1C0) != 0x40 )
      {
        while ( v5 > 0 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(_QWORD *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 72),
                               *(unsigned __int8 *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 88)) == -1 )
          {
            v2 = 4;
            goto LABEL_23;
          }
          --v5;
        }
      }
      if ( std::streambuf::sputn(*(_QWORD *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 72), "Enter license key: ", 19) == 19 )
      {
        while ( v5 > 0 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(_QWORD *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 72),
                               *(unsigned __int8 *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 88)) == -1 )
            goto LABEL_22;
          --v5;
        }
      }
      else
      {
LABEL_22:
        v2 = 4;
LABEL_23:
        v15 = 4;
      }
      *(_QWORD *)(*(int *)(*(_QWORD *)v1 + 4LL) + v1 + 40) = 0;
    }
    catch ( ... )
    {
      LOBYTE(v10) = 1;
      std::ios::setstate(a1 + *(int *)(*(_QWORD *)a1 + 4LL), 4, v10);
      v1 = a1;
      v2 = v15;
      v6 = a1;
    }
  }
  else
  {
    v2 = 4;
  }
  std::ios::setstate(v1 + *(int *)(*(_QWORD *)v1 + 4LL), v2, 0);
  if ( !std::uncaught_exception() )
    std::ostream::_Osfx(v6);
  v11 = *(_QWORD *)(*(int *)(*(_QWORD *)v6 + 4LL) + v6 + 72);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
  return v1;
}
// 14000304B: variable 'v10' is possibly undefined
// 1400040A8: using guessed type __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD);
// 1400040B0: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 1400040B8: using guessed type __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD);
// 1400040C8: using guessed type __int64 __fastcall std::ostream::_Osfx(_QWORD);
// 1400040E0: using guessed type __int64 std::ostream::flush(void);
// 140004108: using guessed type bool std::ios_base::good(std::ios_base *__hidden this);
// 140004118: using guessed type bool std::uncaught_exception(void);

//----- (0000000140001BC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_140001BC0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rdi
  unsigned int v4; // esi
  char v5; // r15
  __int64 v6; // r12
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // r13
  void (__fastcall ***v10)(_QWORD, __int64); // rax
  _BYTE *v11; // rax
  __int64 v12; // r14
  char v13; // r9
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  _QWORD *v16; // rax
  int v17; // eax
  __int64 v18; // r8
  __int64 v19; // rcx
  char v21; // [rsp+20h] [rbp-58h]
  int v22; // [rsp+24h] [rbp-54h]
  _BYTE v25[8]; // [rsp+40h] [rbp-38h] BYREF
  __int64 v26; // [rsp+48h] [rbp-30h]

  v3 = a1;
  v4 = 0;
  v22 = 0;
  v5 = 0;
  v21 = 0;
  v6 = a1;
  v7 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4LL) + a1 + 72);
  if ( v7 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
  if ( (unsigned __int8)std::istream::_Ipfx(v3, 0) )
  {
    v8 = std::ios_base::getloc(v3 + *(int *)(*(_QWORD *)v3 + 4LL), v25);
    v9 = sub_1400018C0(v8);
    if ( v26 )
    {
      v10 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 16LL))(v26);
      if ( v10 )
        (**v10)(v10, 1);
    }
    a2[2] = 0;
    v11 = a2;
    if ( a2[3] > 0xFu )
      v11 = (_BYTE *)*a2;
    *v11 = 0;
    v12 = *(_QWORD *)(*(int *)(*(_QWORD *)v3 + 4LL) + v3 + 40);
    if ( v12 <= 0 || (unsigned __int64)v12 >= 0x7FFFFFFFFFFFFFFFLL )
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    try
    {
      v17 = std::streambuf::sgetc();
      while ( v12 )
      {
        if ( v17 == -1 )
        {
          v4 = 1;
          v22 = 1;
          goto LABEL_31;
        }
        v13 = v17;
        if ( (*(_BYTE *)(*(_QWORD *)(v9 + 24) + 2LL * (unsigned __int8)v17) & 0x48) != 0 )
          goto LABEL_31;
        v14 = a2[2];
        v15 = a2[3];
        if ( v14 >= v15 )
        {
          sub_140001DA0(a2, v15, v18, v17);
        }
        else
        {
          a2[2] = v14 + 1;
          v16 = a2;
          if ( v15 > 0xF )
            v16 = (_QWORD *)*a2;
          *((_BYTE *)v16 + v14) = v13;
          *((_BYTE *)v16 + v14 + 1) = 0;
        }
        v5 = 1;
        v21 = 1;
        --v12;
        v17 = std::streambuf::snextc(*(_QWORD *)(*(int *)(*(_QWORD *)v3 + 4LL) + v3 + 72));
      }
    }
    catch ( ... )
    {
      LOBYTE(v18) = 1;
      std::ios::setstate(a1 + *(int *)(*(_QWORD *)a1 + 4LL), 4, v18);
      v4 = v22;
      v5 = v21;
      v6 = a1;
      v3 = a1;
      goto LABEL_24;
    }
LABEL_31:
    ;
  }
LABEL_24:
  *(_QWORD *)(*(int *)(*(_QWORD *)v3 + 4LL) + v3 + 40) = 0;
  if ( !v5 )
    v4 |= 2u;
  std::ios::setstate(v3 + *(int *)(*(_QWORD *)v3 + 4LL), v4, 0);
  v19 = *(_QWORD *)(*(int *)(*(_QWORD *)v6 + 4LL) + v6 + 72);
  if ( v19 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
  return v3;
}
// 140001D03: variable 'v18' is possibly undefined
// 140004090: using guessed type __int64 __fastcall std::istream::_Ipfx(_QWORD, _QWORD);
// 140004098: using guessed type __int64 std::streambuf::sgetc(void);
// 1400040A0: using guessed type __int64 __fastcall std::streambuf::snextc(_QWORD);
// 1400040B0: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 1400040C0: using guessed type __int64 __fastcall std::ios_base::getloc(_QWORD, _QWORD);

//----- (0000000140001DA0) ----------------------------------------------------
_QWORD *__fastcall sub_140001DA0(_QWORD *Src, __int64 a2, __int64 a3, char a4)
{
  size_t v4; // rbp
  __int64 v5; // rbx
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdx
  __int64 v10; // rcx
  size_t v11; // rcx
  _QWORD *v12; // rdi
  size_t v13; // rax
  void *v14; // rax
  _QWORD *v15; // rbx

  v4 = Src[2];
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 == 0x7FFFFFFFFFFFFFFFLL )
    sub_140001200();
  v8 = Src[3];
  v9 = (v4 + 1) | 0xF;
  if ( v9 > 0x7FFFFFFFFFFFFFFFLL || (v10 = v8 >> 1, v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1)) )
  {
    v13 = 0x8000000000000027uLL;
  }
  else
  {
    v5 = (v4 + 1) | 0xF;
    if ( v9 < v10 + v8 )
      v5 = v10 + v8;
    v11 = v5 + 1;
    if ( v5 == -1 )
    {
      v12 = 0;
      goto LABEL_15;
    }
    if ( v11 < 0x1000 )
    {
      v12 = operator new(v11);
      goto LABEL_15;
    }
    v13 = v5 + 40;
    if ( v5 + 40 < (unsigned __int64)(v5 + 1) )
      sub_140001160();
  }
  v14 = operator new(v13);
  if ( !v14 )
    goto LABEL_20;
  v12 = (_QWORD *)(((unsigned __int64)v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v12 - 1) = v14;
LABEL_15:
  Src[2] = v4 + 1;
  Src[3] = v5;
  if ( v8 <= 0xF )
  {
    memcpy(v12, Src, v4);
    *((_BYTE *)v12 + v4) = a4;
    *((_BYTE *)v12 + v4 + 1) = 0;
    goto LABEL_22;
  }
  v15 = (_QWORD *)*Src;
  memcpy(v12, (const void *)*Src, v4);
  *((_BYTE *)v12 + v4) = a4;
  *((_BYTE *)v12 + v4 + 1) = 0;
  if ( v8 + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v15 - *(v15 - 1) - 8 <= 0x1F )
    {
      v15 = (_QWORD *)*(v15 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  j_j_free(v15);
LABEL_22:
  *Src = v12;
  return Src;
}

//----- (0000000140002044) ----------------------------------------------------
_QWORD *__fastcall sub_140002044(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 140004358: using guessed type void *type_info::`vftable';

//----- (0000000140002460) ----------------------------------------------------
_QWORD *__fastcall sub_140002460(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad allocation";
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 140004390: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140002480) ----------------------------------------------------
void __noreturn sub_140002480()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_140002460(pExceptionObject);
  throw (std::bad_alloc *)pExceptionObject;
}
// 140002480: using guessed type void __noreturn sub_140002480();

//----- (0000000140002794) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0;
}

//----- (00000001400027A8) ----------------------------------------------------
void sub_1400027A8()
{
  InitializeSListHead(&stru_140006700);
}
// 140006700: using guessed type union _SLIST_HEADER stru_140006700;

//----- (00000001400027B8) ----------------------------------------------------
char sub_1400027B8()
{
  return 1;
}

//----- (00000001400027C0) ----------------------------------------------------
void *sub_1400027C0()
{
  return &unk_140006710;
}

//----- (00000001400027C8) ----------------------------------------------------
void *sub_1400027C8()
{
  return &unk_140006718;
}

//----- (00000001400027F8) ----------------------------------------------------
void *sub_1400027F8()
{
  return &unk_140006750;
}

//----- (0000000140002800) ----------------------------------------------------
void *sub_140002800()
{
  return &unk_140006748;
}

//----- (0000000140002808) ----------------------------------------------------
void sub_140002808()
{
  dword_140006720 = 0;
}
// 140006720: using guessed type int dword_140006720;

//----- (0000000140002A20) ----------------------------------------------------
void sub_140002A20()
{
  void (**i)(void); // rbx

  for ( i = qword_140004CF0; i < qword_140004CF0; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 140004CF0: using guessed type void (*qword_140004CF0[2])(void);

//----- (0000000140002A5C) ----------------------------------------------------
void __fastcall sub_140002A5C()
{
  void (**i)(void); // rbx

  for ( i = &qword_140004D00; i < &qword_140004D00; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 140004D00: using guessed type void (*qword_140004D00)(void);

//----- (0000000140002A98) ----------------------------------------------------
__int64 sub_140002A98()
{
  int v5; // r10d
  int v6; // r8d
  int v7; // r9d
  int v8; // r14d
  int v14; // edi
  int v15; // eax
  unsigned __int64 v16; // rax
  __int64 v17; // rcx
  int v18; // r8d
  int v19; // r9d
  int v20; // esi
  int v21; // r10d
  unsigned int v22; // r11d
  unsigned __int64 v38; // rax
  int v39; // eax
  unsigned __int64 v40; // rax
  __int64 v41; // rcx
  int v43; // [rsp+30h] [rbp+20h]

  _RAX = 0;
  __asm { cpuid }
  v5 = _RDX ^ 0x49656E69;
  v6 = _RCX ^ 0x6C65746E;
  v7 = _RBX;
  v8 = _RAX;
  _RAX = 1;
  __asm { cpuid }
  v14 = _RCX;
  if ( !(v7 ^ 0x756E6547 | v6 | v5)
    && ((qword_140006068 = -1, v15 = _RAX & 0xFFF3FF0, qword_140006060 = 0x8000, v15 == 67264)
     || v15 == 132704
     || v15 == 132720
     || (v16 = (unsigned int)(v15 - 198224), (unsigned int)v16 <= 0x20) && (v17 = 0x100010001LL, _bittest64(&v17, v16))) )
  {
    v18 = dword_140006728 | 1;
    dword_140006728 |= 1u;
  }
  else
  {
    v18 = dword_140006728;
  }
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if ( v8 >= 7 )
  {
    _RAX = 7;
    __asm { cpuid }
    v20 = _RDX;
    v19 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      dword_140006728 = v18 | 2;
    if ( (int)_RAX >= 1 )
    {
      _RAX = 7;
      __asm { cpuid }
      v21 = _RDX;
    }
    _RAX = 36;
    if ( v8 >= 36 )
    {
      __asm { cpuid }
      v22 = _RBX;
    }
  }
  v38 = qword_140006050 & 0xFFFFFFFFFFFFFFFEuLL;
  dword_140006058 = 1;
  dword_14000605C = 2;
  qword_140006050 &= ~1uLL;
  if ( (v14 & 0x100000) != 0 )
  {
    v38 &= ~0x10uLL;
    dword_140006058 = 2;
    qword_140006050 = v38;
    dword_14000605C = 6;
  }
  if ( (v14 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    v43 = v38;
    if ( (v14 & 0x10000000) == 0 || (v38 & 6) != 6 )
    {
LABEL_32:
      if ( (v21 & 0x200000) != 0 && (*(_QWORD *)&v43 & 0x80000LL) != 0 )
        qword_140006050 &= ~0x80uLL;
      return 0;
    }
    v39 = dword_14000605C | 8;
    dword_140006058 = 3;
    dword_14000605C |= 8u;
    if ( (v19 & 0x20) != 0 )
    {
      dword_140006058 = 5;
      dword_14000605C = v39 | 0x20;
      v40 = qword_140006050 & 0xFFFFFFFFFFFFFFFDuLL;
      qword_140006050 &= ~2uLL;
      if ( (v19 & 0xD0030000) != 0xD0030000 )
      {
LABEL_26:
        if ( (v20 & 0x800000) != 0 )
          qword_140006050 = v40 & 0xFFFFFFFFFEFFFFFFuLL;
        if ( (v21 & 0x80000) != 0 && (v43 & 0xE0) == 0xE0 )
        {
          dword_140006724 = v22 & 0x400FF;
          v41 = qword_140006050 & ~(HIWORD(v22) & 7 | 0x1000028LL);
          qword_140006050 = v41;
          if ( (v22 & 0x400FF) > 1 )
            qword_140006050 = v41 & 0xFFFFFFFFFFFFFFBFuLL;
        }
        goto LABEL_32;
      }
      if ( (v43 & 0xE0) == 0xE0 )
      {
        dword_14000605C |= 0x40u;
        v40 = qword_140006050 & 0xFFFFFFFFFFFFFFDBuLL;
        dword_140006058 = 6;
        qword_140006050 &= 0xFFFFFFFFFFFFFFDBuLL;
        goto LABEL_26;
      }
    }
    v40 = qword_140006050;
    goto LABEL_26;
  }
  return 0;
}
// 140002A98: using guessed type __int64 sub_140002A98();
// 140006050: using guessed type __int64 qword_140006050;
// 140006058: using guessed type int dword_140006058;
// 14000605C: using guessed type int dword_14000605C;
// 140006060: using guessed type __int64 qword_140006060;
// 140006068: using guessed type __int64 qword_140006068;
// 140006724: using guessed type int dword_140006724;
// 140006728: using guessed type int dword_140006728;

//----- (0000000140002D78) ----------------------------------------------------
void *__fastcall sub_140002D78(__int64 a1)
{
  _QWORD *v2; // rdx
  void *result; // rax

  v2 = malloc(0x10u);
  if ( !v2 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  result = Block;
  *v2 = Block;
  v2[1] = a1;
  Block = v2;
  return result;
}

//----- (0000000140002FB0) ----------------------------------------------------
__int64 __fastcall sub_140002FB0(__int64 a1, __int64 a2)
{
  return sub_1400012F0(*(_QWORD *)(a2 + 40));
}
// 1400012F0: using guessed type __int64 __fastcall sub_1400012F0(_QWORD);

//----- (0000000140002FC0) ----------------------------------------------------
__int64 __fastcall sub_140002FC0(__int64 a1, __int64 a2)
{
  return sub_1400012F0(a2 + 144);
}
// 1400012F0: using guessed type __int64 __fastcall sub_1400012F0(_QWORD);

//----- (0000000140002FCC) ----------------------------------------------------
__int64 __fastcall sub_140002FCC(__int64 a1, __int64 a2)
{
  return sub_1400012F0(a2 + 176);
}
// 1400012F0: using guessed type __int64 __fastcall sub_1400012F0(_QWORD);

//----- (0000000140002FD8) ----------------------------------------------------
__int64 __fastcall sub_140002FD8(__int64 a1, __int64 a2)
{
  return sub_1400012F0(*(_QWORD *)(a2 + 32));
}
// 1400012F0: using guessed type __int64 __fastcall sub_1400012F0(_QWORD);

//----- (0000000140002FF0) ----------------------------------------------------
void __fastcall sub_140002FF0(__int64 a1, __int64 a2)
{
  std::_Lockit::~_Lockit((std::_Lockit *)(a2 + 40));
}
// 1400040F0: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);

//----- (0000000140003070) ----------------------------------------------------
__int64 __fastcall sub_140003070(__int64 a1, __int64 a2)
{
  return sub_140001F40(a2 + 48);
}
// 140001F40: using guessed type __int64 __fastcall sub_140001F40(_QWORD);

//----- (000000014000307C) ----------------------------------------------------
__int64 __fastcall sub_14000307C(__int64 a1, __int64 a2)
{
  return sub_140001F10(a2 + 48);
}
// 140001F10: using guessed type __int64 __fastcall sub_140001F10(_QWORD);

//----- (0000000140003088) ----------------------------------------------------
__int64 __fastcall sub_140003088(__int64 a1, __int64 a2)
{
  return sub_140001500(a2 + 64);
}
// 140001500: using guessed type __int64 __fastcall sub_140001500(_QWORD);

//----- (0000000140003108) ----------------------------------------------------
void sub_140003108()
{
  __int64 v0; // rcx
  void (__fastcall ***v1)(_QWORD, __int64); // rax
  void *v2; // rbx

  while ( 1 )
  {
    v2 = Block;
    if ( !Block )
      break;
    v0 = *((_QWORD *)Block + 1);
    Block = *(void **)Block;
    v1 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16LL))(v0);
    if ( v1 )
      (**v1)(v1, 1);
    free(v2);
  }
}

// #eh34_calls=0 #try=2 #catch=2 #wind=0 #gotos=22
// nfuncs=128 queued=45 decompiled=45 lumina nreq=0 worse=0 better=0
// ALL OK, 45 function(s) have been successfully decompiled
